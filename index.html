<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<title>実寸キャリブレーション＋プレビュー（iOS対応・擬似全画面リフレッシュ付き）</title>
<style>
  :root { --accent: #007aff; }
  body{font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin:16px; line-height:1.5}
  h1{font-size:1.2rem;margin:0 0 8px}
  h2{font-size:1.05rem;margin:16px 0 8px; display:flex; align-items:center; justify-content:space-between; gap:8px}
  .card{border:1px solid #ddd; border-radius:12px; padding:12px; margin:12px 0; box-shadow: 0 1px 2px rgba(0,0,0,.04)}
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .pill{background:#f5f5f5;border:1px solid #e1e1e1;padding:4px 8px;border-radius:999px}
  #creditbar{height:20px;background:#e9e9e9;border:1px solid #bbb;border-radius:10px}
  button{padding:10px 14px; border-radius:10px; border:1px solid #bbb; background:#fff; cursor:pointer}
  button.primary{background:var(--accent); color:#fff; border-color:var(--accent)}
  input[type="number"]{width:90px;padding:8px 10px;border:1px solid #ccc;border-radius:8px}
  .muted{color:#666}
  .grid{display:grid; grid-template-columns: 1fr; gap:12px}
  .stim{background:#fff; padding:8px; border:1px dashed #ccc; border-radius:12px; text-align:center}
  .stim img{display:block; margin:0 auto}
  .toolbar{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
  .tag{padding:6px 10px;border-radius:999px;border:1px solid #ddd;background:#f7f7f7;cursor:pointer}
  .tag.active{background:var(--accent); color:#fff; border-color:var(--accent)}
  .small{font-size:.9em}

  /* Fullscreen exit/controls buttons */
  #exitFs, #refreshFs{
    position:fixed; z-index:9999; display:none;
    padding:10px 14px; border-radius:10px; border:0;
    background:rgba(0,0,0,.75); color:#fff;
  }
  #exitFs{ top:8px; right:8px; }
  #refreshFs{ bottom:8px; right:8px; }

  :fullscreen #exitFs, :-webkit-full-screen #exitFs,
  :fullscreen #refreshFs, :-webkit-full-screen #refreshFs { display:block; }

  /* Real fullscreen preview */
  #previewWrap:fullscreen, #previewWrap:-webkit-full-screen {
    background:#fff; padding:16px; box-sizing:border-box;
  }

  /* Pseudo fullscreen fallback */
  .pseudo-fs #previewWrap {
    position:fixed; inset:0; z-index:9998;
    background:#fff; padding:16px; box-sizing:border-box;
    overflow:auto;
  }
  .pseudo-fs #exitFs, .pseudo-fs #refreshFs { display:block; }
  .hint{font-size:.9em; color:#555; margin-top:6px}
</style>
</head>
<body>
<h1>実寸キャリブレーション＋プレビュー（iOS対応）</h1>

<div class="card">
  <h2>① キャリブレーション</h2>
  <div>灰色バーの幅を、手元の<span class="pill">クレカ横幅 85.6 mm</span>に指で合わせてください。</div>
  <div class="row" style="margin-top:8px">
    <input id="range" type="range" min="50" max="1000" value="320" style="flex:1">
    <button id="save" class="primary">この幅で保存</button>
    <button id="reset">リセット</button>
  </div>
  <div id="creditbar" style="width:320px; margin-top:10px"></div>
  <div class="muted small" id="status" style="margin-top:6px">未保存</div>
</div>

<div class="card">
  <h2>② 表示設定</h2>
  <div class="toolbar">
    <div>幅(mm)：<input id="mm" type="number" step="0.1" value="5"></div>
    <label><input id="shuffle" type="checkbox"> ランダム順</label>
    <label><input id="labels" type="checkbox" checked> ラベル表示</label>
    <button id="apply" class="primary">読み込み/更新</button>
  </div>
  <div class="muted small" style="margin-top:6px">画像は <code>img/manifest.json</code> から読み込みます。</div>
  <div class="toolbar" id="tags" style="margin-top:8px"></div>
</div>

<div class="card" id="previewCard">
  <h2>
    ③ プレビュー
    <span class="row">
      <button id="fsBtn">全画面</button>
      <button id="fsLandBtn">横向きで全画面</button>
      <button id="pseudoBtn">擬似全画面</button>
    </span>
  </h2>
  <div class="hint">iOSの一部ブラウザでは全画面APIが無効です。その場合は「擬似全画面」を使うか、Safariで「ホーム画面に追加」して開いてください。</div>
  <div id="previewWrap">
    <button id="exitFs">✕ 退出</button>
    <button id="refreshFs">↻ 更新</button>
    <div id="out" class="grid"><div class="muted">「読み込み/更新」を押してください。</div></div>
  </div>
</div>

<script>
const range = document.getElementById('range');
const creditbar = document.getElementById('creditbar');
const statusEl = document.getElementById('status');
const saveBtn = document.getElementById('save');
const resetBtn = document.getElementById('reset');
const applyBtn = document.getElementById('apply');
const out = document.getElementById('out');
const mmInput = document.getElementById('mm');
const shuffleCb = document.getElementById('shuffle');
const labelsCb = document.getElementById('labels');
const tagsEl = document.getElementById('tags');
const previewWrap = document.getElementById('previewWrap');
const fsBtn = document.getElementById('fsBtn');
const fsLandBtn = document.getElementById('fsLandBtn');
const pseudoBtn = document.getElementById('pseudoBtn');
const exitFs = document.getElementById('exitFs');
const refreshFs = document.getElementById('refreshFs');
let selectedTag = 'all';

function setBar(px){ creditbar.style.width = px + 'px'; }
range.oninput = e => setBar(e.target.value);
function getK(){ return +localStorage.getItem('mm_per_csspx') || 0; }
function setK(k){ localStorage.setItem('mm_per_csspx', k); statusEl.textContent = k>0 ? `保存済み: 1px = ${k.toFixed(4)} mm` : '未保存'; }
(function init(){ const k = getK(); if(k>0){ statusEl.textContent = `保存済み: 1px = ${k.toFixed(4)} mm`; } setBar(range.value);} )();
saveBtn.onclick = ()=>{ const px = parseFloat(getComputedStyle(creditbar).width); const mmPerPx = 85.6 / px; setK(mmPerPx); alert('保存しました。以降はズームを変えないでください。'); };
resetBtn.onclick = ()=>{ localStorage.removeItem('mm_per_csspx'); setK(0); };

function pxFromMM(mm){ const k = getK(); if(!(k>0)) { alert('先に①のキャリブレーションを保存してください。'); throw new Error('no calib'); } return Math.max(1, Math.round(mm / k)); }
function shuffle(arr){ for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } return arr; }

function renderTags(items){
  const tags = Array.from(new Set(items.flatMap(x => x.tags || [])));
  tags.unshift('all');
  tagsEl.innerHTML = '';
  for(const t of tags){
    const b = document.createElement('button');
    b.className = 'tag' + (t===selectedTag?' active':'');
    b.textContent = t;
    b.onclick = ()=>{ selectedTag = t; render(items); renderTags(items); };
    tagsEl.appendChild(b);
  }
}

function filterByTag(items){
  if(selectedTag==='all') return items;
  return items.filter(x => (x.tags||[]).includes(selectedTag));
}

async function loadManifest(){
  const res = await fetch('img/manifest.json?v=' + Date.now());
  if(!res.ok) throw new Error('manifest.json が読み込めませんでした');
  return res.json();
}

function render(items){
  out.innerHTML = '';
  const wantMM = +mmInput.value;
  const px = pxFromMM(wantMM);
  let list = filterByTag(items).slice();
  if(shuffleCb.checked) list = shuffle(list);
  if(!list.length){ out.innerHTML = '<div class="muted">選択されたタグに画像がありません。</div>'; return; }
  for(const item of list){
    const d = document.createElement('div');
    d.className = 'stim';
    const img = new Image();
    img.src = 'img/' + item.src;
    img.style.width = px + 'px';
    img.style.height = 'auto';
    img.decoding = 'async';
    img.loading = 'eager';
    d.appendChild(img);
    if(labelsCb.checked){
      const cap = document.createElement('div');
      cap.className = 'muted';
      cap.style.marginTop = '6px';
      cap.textContent = `${item.label || item.src} — 幅 ${wantMM} mm（${px}px）`;
      d.appendChild(cap);
    }
    out.appendChild(d);
  }
}

// Fullscreen helpers
function canRealFullscreen(){
  return !!(document.fullscreenEnabled || document.webkitFullscreenEnabled || 
            Element.prototype.requestFullscreen || Element.prototype.webkitRequestFullscreen);
}
function requestFs(el){
  if (el.requestFullscreen) return el.requestFullscreen();
  if (el.webkitRequestFullscreen) return el.webkitRequestFullscreen();
  if (el.msRequestFullscreen) return el.msRequestFullscreen();
  if (el.mozRequestFullScreen) return el.mozRequestFullScreen();
  return Promise.reject();
}
function exitFsFn(){
  if (document.exitFullscreen) return document.exitFullscreen();
  if (document.webkitExitFullscreen) return document.webkitExitFullscreen();
  if (document.msExitFullscreen) return document.msExitFullscreen();
  if (document.mozCancelFullScreen) return document.mozCancelFullScreen();
  return Promise.resolve();
}
async function enterFullscreen(landscape=false){
  try{
    if(!canRealFullscreen()) throw new Error('no-fs');
    await requestFs(previewWrap);
    if(landscape && screen.orientation && screen.orientation.lock){
      try{ await screen.orientation.lock('landscape'); }catch(e){ /* ignore */ }
    }
  }catch(e){
    document.documentElement.classList.add('pseudo-fs');
    // No alert to avoid blocking clicks; a small toast could be added if needed
  }
}
async function exitFullscreen(){
  try{
    if(document.fullscreenElement || document.webkitFullscreenElement){
      await exitFsFn();
    } else {
      document.documentElement.classList.remove('pseudo-fs');
    }
  }catch(e){ /* ignore */ }
}

// Wire buttons
document.getElementById('fsBtn').onclick = ()=> enterFullscreen(false);
document.getElementById('fsLandBtn').onclick = ()=> enterFullscreen(true);
document.getElementById('pseudoBtn').onclick = ()=> document.documentElement.classList.add('pseudo-fs');
document.getElementById('exitFs').onclick = ()=> exitFullscreen();
document.getElementById('refreshFs').onclick = ()=> applyBtn.click(); // in-overlay refresh

function onFsChange(){
  const fs = document.fullscreenElement || document.webkitFullscreenElement;
  const pseudo = document.documentElement.classList.contains('pseudo-fs');
  document.getElementById('exitFs').style.display = (fs || pseudo) ? 'block' : 'none';
  document.getElementById('refreshFs').style.display = (fs || pseudo) ? 'block' : 'none';
}
document.addEventListener('fullscreenchange', onFsChange);
document.addEventListener('webkitfullscreenchange', onFsChange);

// Initial
</script>
</body>
</html>
